quilt 0.1 quilt_core design
-----------------------------

Module: quilt_core

Type: Library

External Dependencies:
    python-configparser
    python-pyro

Responsibilities:
    utility functions common to all quilt modules

Classes:

    # Responsible for access to quilt configuration
    class QuiltConfig():
        
        ###########
        # Constants
        ###########

        # The name of the environment variable that defines the location
        # of the quilt config directory.  This will be the filesystem path to a 
        # directory containing a quilt.cfg file.  ALso it may have a smd.d 
        # subdirectory where sourcemaster configurations may be
        QUILT_CFG_DIR_VAR='QUILT_CFG_DIR'

        ############
        # Operations
        ############
        
        # Constructor, reads the configuration 
        def __init__():
            # default configuration location to /etc/quilt
            # if QUILT_CFG_DIR_VAR set, set location off of that value
            # if config file exists at location, read it in
        
        # Access a configuration value.  Configuraiton values can be
        # specified with a section and a name.  The configuration value is
        # returned.  If the specified value is not present the passed in
        # default is returned.
        def GetValue(        # [out] string
            self,
            sectionName,     # [in] string, name of section
            valueName,       # [in] string, name of value
            default)         # [in] string, value of default

        # iterate through the source managers defined in the configuration
        # these will be the files inside of $QUILT_CFG/smd.d
        def GetSourceManagers(  # [out] list of all defined source managers
            self)


    class QueryMasterClient
        
        # Connect to the query master
        void ConnectToQueryMaster():
            # Access the QueryMaster's registrar's host and port from the config            
            # access the Query Master's instance name, create a proxy to it
            # store a reference to the query master as a member variable
            # register the client with the query master
            # record the name the master assigned us as a member variable
            # call OnConnectionComplete()
        

        # funciton called when registration of this client is complete.
        # Inteded for overriding by the implementing client.
        void OnConnectionComplete()


        # Constructor
        void __init__()

        def GetType()
            # return the type id of this class

        string GetRegisteredName()
            # return the name the query manager assigned to this client

    # Disconnect from the query Master
    void DisconnectFromQueryMaster()
        # call query master's unregister function

Functions:

    # Used to publish the client as a remote object, and complete the
    #   connection with the query master
    static query_master_client_main_helper(
            clientObjectDic        # map of instances to names of objects to
                                   # host as pyro objects)
        # Use QuiltConfig to read in configuration 
        # access the registrar's host and port number from config
        # iterate the names and objects in clientObjectDic
            # register the clientObject with the local PyRo Daemon with 
            # use the key name as the object name        
            # call the ConnectToQueryMaster to complete registration
        # start the Daemon's event loop
    
        Notes:
            We wouldn't necessarily have to register the client for two way
            communicaiton if it was going to perform a non validating submit.
            However, I feel that in the future we will care more about security of
            the system, and forcing it to register will enable the two way calling
            likely used for a secret handshake

            Is there a potential timing issue here?  If the master makes a return
            call after we submit the query before our daemon event loop gets
            rolling?  Keep and eye on this.

            TODO hardening:
            The clients are not hardened to unregister themselves when
            exceptions are thrown at this time. 
        
Schema:

    Main Config File
    ----------------

    # Configuration file has the following defined sections values and
    # defaults

    [registrar]
    port : ''           # port used by nameserver 'name' default is random

    [query_master]
    registrar_host : ''      # hostname of the registrar default is
                             # localhost
    registrar_port : ''      # port of the registrar default search for
                             # registrar port (could be wrong if multiple
                             # pyro nameservers on system)
    name : 'query_master'    # name for of the query master instance

    [source_managers]
    config_dir  : '$QUILT_CFG/smd.d'    # directory containing smd configs

    [testing]
    includes    :   '*'     # files to run as testing scripts
    sleep       :   '1'     # minutes to sleep between test 

    Soure Manager Config File
    -------------------------

    [NAME]      # the name of the source manager
    key         :   value   # specific per source manager
