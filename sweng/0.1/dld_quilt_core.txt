quilt 0.1 quilt_core design
-----------------------------

Module: quilt_core

Type: Library

External Dependencies:
    python-configparser
    python-pyro

Responsibilities:
    utility functions common to all quilt modules

Classes:

    # responsible for common daemon functionality
    class QuiltDaemon:
        setup_process(name)
            # perform common daemon setup stuff
            # set stdin, stdout, stderr to TTY or to null if no TTY
            # set the pid file path and the pid timeout

    # Responsible for access to quilt configuration
    class QuiltConfig():
        
        ###########
        # Constants
        ###########

        # The name of the environment variable that defines the location
        # of the quilt config directory.  This will be the filesystem path to a 
        # directory containing a quilt.cfg file.  ALso it may have a smd.d 
        # subdirectory where sourcemaster configurations may be
        QUILT_CFG_DIR_VAR='QUILT_CFG_DIR'

        ############
        # Operations
        ############
        
        # Constructor, reads the configuration 
        def __init__():
            # default configuration location to /etc/quilt
            # if QUILT_CFG_DIR_VAR set, set location off of that value
            # if config file exists at location, read it in
        
        # Access a configuration value.  Configuraiton values can be
        # specified with a section and a name.  The configuration value is
        # returned.  If the specified value is not present the passed in
        # default is returned.
        def GetValue(        # [out] string
            self,
            sectionName,     # [in] string, name of section
            valueName,       # [in] string, name of value
            default)         # [in] string, value of default

        # iterate through the source managers defined in the configuration
        # these will be the files inside of $QUILT_CFG/smd.d
        def GetSourceManagers(  # [out] list of all defined source managers
            self)


    class QueryMasterClient : Pyro.core.SynchronizedObjBase
        
        Note: To avoid having to deal with theading and locking, all
            methods are considered locked, we are using SynchronizedObjBase
            
        # create a lock for this class, coarse grained but
        # proably good enough.
        self._lock = threading.lock()

        # Connect to the query master
        void ConnectToQueryMaster():
            # Access the QueryMaster's registrar's host and port from the config            
            # access the Query Master's instance name, create a proxy to it
            # store a reference to the query master as a member variable
            # register the client with the query master
            # record the name the master assigned us as a member variable
            # call OnConnectionComplete()
        

        # funciton called when registration of this client is complete.
        # Inteded for overriding by the implementing client.
        void OnConnectionComplete()


        # Constructor
        void __init__( basename )
            # set a local name based off the base name that will be 
            # unique for this machine

        def GetType()
            # return the type id of this class

        string GetRegisteredName()
            # return the name the query manager assigned to this client

        # Disconnect from the query Master
        void DisconnectFromQueryMaster()
            # call query master's unregister function

Functions:

    # Used to publish the client as a remote object, and complete the
    #   connection with the query master
    static query_master_client_main_helper(
            clientObjectDic        # map of instances to names of objects to
                                   # host as pyro objects)
        # Use QuiltConfig to read in configuration 
        # access the registrar's host and port number from config
        # iterate the names and objects in clientObjectDic
            # register the clientObject with the local PyRo Daemon with 
            # use the key name as the object name        
            # call the ConnectToQueryMaster to complete registration
        # start the Daemon's event loop
    
        Notes:
            We wouldn't necessarily have to register the client for two way
            communicaiton if it was going to perform a non validating submit.
            However, I feel that in the future we will care more about security of
            the system, and forcing it to register will enable the two way calling
            likely used for a secret handshake

            Is there a potential timing issue here?  If the master makes a return
            call after we submit the query before our daemon event loop gets
            rolling?  Keep and eye on this.

            TODO hardening:
            The clients are not hardened to unregister themselves when
            exceptions are thrown at this time. 
        
Schema:

    Main Config File
    ----------------

    # Configuration file has the following defined sections values and
    # defaults, all pyro objects hosted on this machine will use this
    # registrar

    [registrar]
    port : None           # port used by nameserver 'name' default is random
    host : None           # host used by nameserver default is localhost

    # the location of the query master.  This section is for the client's
    # to be able to find the query master.  The query master machine does
    # not use this section for registrat informaiton, it will be 
    # regestered at location specified in [registrar] section with the
    # name specified in this section.
    [query_master]
    registrar_host : None      # hostname of the registrar default is
                             # localhost
    registrar_port : None      # port of the registrar default search for
                             # registrar port (could be wrong if multiple
                             # pyro nameservers on system)
    name : 'query_master'    # name for of the query master instance

    [source_managers]
    config_dir  : '$QUILT_CFG/smd.d'    # directory containing smd configs

    [testing]
    includes    :   ['*_testcase.py']    # file globs to run as testing 
                                         # scripts (no pathing
                                #     needed assumed to be in test lib dir)
                                #     like ['*TestSuite1*', *TestSuite2* ] 
    sleep       :   1     # minutes to sleep between test (float supported)

    Soure Manager Config File
    -------------------------

    [NAME]      # the name of the source manager
    key         :   value   # specific per source manager
